# Mobile Architecture Guidelines

## Current Architecture Overview

í˜„ì¬ ëª¨ë°”ì¼ ì•±ì€ **ì „í†µì ì¸ React Native êµ¬ì¡°**ë¥¼ ì‚¬ìš©í•˜ê³  ìˆìœ¼ë©°, Expo Router ëŒ€ì‹  **App.tsx ê¸°ë°˜**ì˜ ì•„í‚¤í…ì²˜ë¥¼ ì±„íƒí•˜ê³  ìˆìŠµë‹ˆë‹¤.

## Architecture Patterns

### 1. App.tsx ê¸°ë°˜ êµ¬ì¡°

```typescript
// App.tsx - ë©”ì¸ ì•± ì§„ì…ì 
import React, { useRef } from "react";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { AuthProvider } from "./context/AuthContext";
import AppContent from "./AppContent";

const App: React.FC = () => {
  const queryClientRef = useRef<QueryClient>();
  if (!queryClientRef.current) {
    queryClientRef.current = new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: 1000 * 60 * 5,
          gcTime: 1000 * 60 * 30,
          refetchOnReconnect: true,
          refetchOnMount: false,
          refetchOnWindowFocus: false,
        },
      },
    });
  }

  return (
    <SafeAreaProvider>
      <QueryClientProvider client={queryClientRef.current}>
        <AuthProvider>
          <AppContent />
        </AuthProvider>
      </QueryClientProvider>
    </SafeAreaProvider>
  );
};

export default App;
```

### 2. ì»´í¬ë„ŒíŠ¸ ê³„ì¸µ êµ¬ì¡°

```
App.tsx (ë£¨íŠ¸)
â”œâ”€â”€ AppContent (ì¸ì¦ ìƒíƒœ ê´€ë¦¬)
â”‚   â”œâ”€â”€ MainScreen (ë¡œê·¸ì¸ í›„ ë©”ì¸ í™”ë©´)
â”‚   â”‚   â”œâ”€â”€ MainLayout
â”‚   â”‚   â”‚   â”œâ”€â”€ Header
â”‚   â”‚   â”‚   â””â”€â”€ Content Area
â”‚   â”‚   â””â”€â”€ TabBar
â”‚   â””â”€â”€ LoginScreen (ë¡œê·¸ì¸ í™”ë©´)
â”‚       â”œâ”€â”€ StarField (ë°°ê²½)
â”‚       â”œâ”€â”€ Logo & Progress
â”‚       â””â”€â”€ Auth Buttons
```

### 3. ë””ë ‰í† ë¦¬ êµ¬ì¡° íŒ¨í„´

#### ì»´í¬ë„ŒíŠ¸ ë¶„ë¥˜

- **`components/common/`**: ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê³µí†µ ì»´í¬ë„ŒíŠ¸
- **`components/features/`**: íŠ¹ì • ê¸°ëŠ¥ì— íŠ¹í™”ëœ ì»´í¬ë„ŒíŠ¸
- **`screens/`**: ì „ì²´ í™”ë©´ì„ ë‹´ë‹¹í•˜ëŠ” ì»´í¬ë„ŒíŠ¸
- **`layouts/`**: ë ˆì´ì•„ì›ƒì„ ë‹´ë‹¹í•˜ëŠ” ì»´í¬ë„ŒíŠ¸
- **`features/`**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ í¬í•¨ëœ ëª¨ë“ˆ

#### íŒŒì¼ ëª…ëª… ê·œì¹™

```typescript
// ì»´í¬ë„ŒíŠ¸ íŒŒì¼ëª…: PascalCase
ActionButton.tsx;
DiaryCalendar.tsx;
MainScreen.tsx;

// ìœ í‹¸ë¦¬í‹° íŒŒì¼ëª…: camelCase
secureStorage.ts;
challengeUtils.ts;

// ìƒìˆ˜ íŒŒì¼ëª…: PascalCase
Colors.ts;
queryConfig.ts;
```

## State Management

### 1. React Context íŒ¨í„´

```typescript
// context/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect } from "react";

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  token: string | null;
  login: (userData: User, token: string) => Promise<void>;
  logout: () => Promise<void>;
  updateToken: (token: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = async (userData: User, authToken: string) => {
    // ë¡œê·¸ì¸ ë¡œì§
    setUser(userData);
    setToken(authToken);
    setIsAuthenticated(true);
  };

  const logout = async () => {
    // ë¡œê·¸ì•„ì›ƒ ë¡œì§
    setUser(null);
    setToken(null);
    setIsAuthenticated(false);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated,
        token,
        login,
        logout,
        updateToken: setToken,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
```

### 2. React Query ì¤‘ì•™ê´€ë¦¬ íŒ¨í„´

#### App.tsxì—ì„œ QueryClient ì¤‘ì•™ ê´€ë¦¬

```typescript
// App.tsx - QueryClient ì¤‘ì•™ ì„¤ì •
import React, { useRef } from "react";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { AuthProvider } from "./context/AuthContext";
import AppContent from "./AppContent";

const App: React.FC = () => {
  const queryClientRef = useRef<QueryClient>();
  if (!queryClientRef.current) {
    queryClientRef.current = new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: 1000 * 60 * 5, // 5ë¶„
          gcTime: 1000 * 60 * 30, // 30ë¶„
          refetchOnReconnect: true,
          refetchOnMount: false,
          refetchOnWindowFocus: false,
          retry: (failureCount, error) => {
            // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ì•„ë‹Œ ê²½ìš° ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
            if (error?.status === 401 || error?.status === 403) {
              return false;
            }
            return failureCount < 3;
          },
        },
        mutations: {
          retry: false, // ë®¤í…Œì´ì…˜ì€ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
        },
      },
    });
  }

  return (
    <SafeAreaProvider>
      <QueryClientProvider client={queryClientRef.current}>
        <AuthProvider>
          <AppContent />
        </AuthProvider>
      </QueryClientProvider>
    </SafeAreaProvider>
  );
};

export default App;
```

#### ì¤‘ì•™í™”ëœ ì¿¼ë¦¬ í›… íŒ¨í„´

```typescript
// hooks/useQueries.ts - ì¤‘ì•™í™”ëœ ì¿¼ë¦¬ ê´€ë¦¬
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  getDiaryCalendar,
  createDiaryEntry,
  getAllChallenges,
  getMyChallenges,
} from "@mooddisk/api";

// ì¿¼ë¦¬ í‚¤ ì¤‘ì•™ ê´€ë¦¬
export const queryKeys = {
  diaryCalendar: (year: number, month: number) => [
    "diaryCalendar",
    year,
    month,
  ],
  diaryYear: (year: number) => ["diaryYear", year],
  allChallenges: () => ["allChallenges"],
  myChallenges: () => ["myChallenges"],
  userInfo: (userId: number) => ["userInfo", userId],
} as const;

// ì¼ê¸° ë‹¬ë ¥ ì¿¼ë¦¬
export const useDiaryCalendar = (year: number, month: number) => {
  return useQuery({
    queryKey: queryKeys.diaryCalendar(year, month),
    queryFn: () => getDiaryCalendar(year, month),
    staleTime: 1000 * 60 * 5, // 5ë¶„
    enabled: !!year && !!month, // yearì™€ monthê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
  });
};

// ì¼ê¸° ë…„ë„ ë°ì´í„° ì¿¼ë¦¬
export const useDiaryYear = (year: number) => {
  return useQuery({
    queryKey: queryKeys.diaryYear(year),
    queryFn: () => getDiaryYear(year),
    staleTime: 1000 * 60 * 10, // 10ë¶„
    enabled: !!year,
  });
};

// ëª¨ë“  ì±Œë¦°ì§€ ì¿¼ë¦¬
export const useAllChallenges = () => {
  return useQuery({
    queryKey: queryKeys.allChallenges(),
    queryFn: getAllChallenges,
    staleTime: 1000 * 60 * 15, // 15ë¶„
  });
};

// ë‚´ ì±Œë¦°ì§€ ì¿¼ë¦¬
export const useMyChallenges = () => {
  return useQuery({
    queryKey: queryKeys.myChallenges(),
    queryFn: getMyChallenges,
    staleTime: 1000 * 60 * 5, // 5ë¶„
  });
};

// ì¼ê¸° ìƒì„± ë®¤í…Œì´ì…˜
export const useCreateDiaryEntry = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createDiaryEntry,
    onSuccess: (data, variables) => {
      // ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
      const year = new Date(variables.date).getFullYear();
      const month = new Date(variables.date).getMonth() + 1;

      queryClient.invalidateQueries({
        queryKey: queryKeys.diaryCalendar(year, month),
      });
      queryClient.invalidateQueries({ queryKey: queryKeys.diaryYear(year) });
    },
    onError: (error) => {
      console.error("ì¼ê¸° ìƒì„± ì‹¤íŒ¨:", error);
    },
  });
};
```

#### ë¡œë”© ìƒíƒœ ì¤‘ì•™ ê´€ë¦¬

```typescript
// hooks/useLoadingState.ts - ë¡œë”© ìƒíƒœ ì¤‘ì•™ ê´€ë¦¬
import { useQueryClient } from "@tanstack/react-query";
import { useMemo } from "react";

export const useLoadingState = (queryKeys: string[][]) => {
  const queryClient = useQueryClient();

  return useMemo(() => {
    const isLoading = queryKeys.some(
      (queryKey) => queryClient.getQueryState(queryKey)?.status === "pending"
    );

    const isError = queryKeys.some(
      (queryKey) => queryClient.getQueryState(queryKey)?.status === "error"
    );

    return { isLoading, isError };
  }, [queryClient, queryKeys]);
};

// ì‚¬ìš© ì˜ˆì‹œ
const DiaryScreen = () => {
  const year = new Date().getFullYear();
  const month = new Date().getMonth() + 1;

  const { isLoading, isError } = useLoadingState([
    queryKeys.diaryCalendar(year, month),
    queryKeys.diaryYear(year),
  ]);

  if (isLoading) {
    return <LoadingSpinner text="ì¼ê¸° ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘..." />;
  }

  if (isError) {
    return <ErrorView message="ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." />;
  }

  return <DiaryContent />;
};
```

## Navigation Pattern

### 1. React Navigation ê¸°ë°˜

í˜„ì¬ í”„ë¡œì íŠ¸ëŠ” **expo-router**ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ë§Œ ì‚¬ìš©í•˜ì§€ ì•Šê³ , **React Navigation**ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

```typescript
// layouts/TabBar.tsx
import React from "react";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

const Tab = createBottomTabNavigator();

const TabBar = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: keyof typeof Ionicons.glyphMap;

          if (route.name === "Home") {
            iconName = focused ? "home" : "home-outline";
          } else if (route.name === "Diary") {
            iconName = focused ? "book" : "book-outline";
          } else if (route.name === "Challenge") {
            iconName = focused ? "trophy" : "trophy-outline";
          } else if (route.name === "Disk") {
            iconName = focused ? "disc" : "disc-outline";
          } else if (route.name === "MyPage") {
            iconName = focused ? "person" : "person-outline";
          } else {
            iconName = "help-outline";
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: "#007AFF",
        tabBarInactiveTintColor: "#8E8E93",
        headerShown: false,
      })}
    >
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Diary" component={DiaryScreen} />
      <Tab.Screen name="Challenge" component={ChallengeScreen} />
      <Tab.Screen name="Disk" component={DiskScreen} />
      <Tab.Screen name="MyPage" component={MyPageScreen} />
    </Tab.Navigator>
  );
};

export default TabBar;
```

## Styling Patterns

### 1. StyleSheet íŒ¨í„´

```typescript
// components/common/buttons/ActionButton.tsx
import { StyleSheet } from "react-native";

const styles = StyleSheet.create({
  button: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: "center",
    justifyContent: "center",
    minHeight: 44, // í„°ì¹˜ ì¹œí™”ì  ìµœì†Œ ë†’ì´
  },
  primary: {
    backgroundColor: "#007AFF",
  },
  secondary: {
    backgroundColor: "#F2F2F7",
  },
  text: {
    fontSize: 16,
    fontWeight: "600",
  },
  primaryText: {
    color: "#FFFFFF",
  },
  secondaryText: {
    color: "#000000",
  },
});
```

### 2. í…Œë§ˆ ì‹œìŠ¤í…œ

```typescript
// constants/Colors.ts
const tintColorLight = "#2f95dc";
const tintColorDark = "#fff";

export default {
  light: {
    text: "#000",
    background: "#fff",
    tint: tintColorLight,
    tabIconDefault: "#ccc",
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: "#fff",
    background: "#000",
    tint: tintColorDark,
    tabIconDefault: "#ccc",
    tabIconSelected: tintColorDark,
  },
};
```

## Loading & Error Management

### 1. ì¤‘ì•™í™”ëœ ë¡œë”© ê´€ë¦¬

#### ì „ì—­ ë¡œë”© ìƒíƒœ ê´€ë¦¬

```typescript
// context/LoadingContext.tsx - ì „ì—­ ë¡œë”© ìƒíƒœ ê´€ë¦¬
import React, { createContext, useContext, useState, useCallback } from "react";
import { View, StyleSheet } from "react-native";
import LoadingSpinner from "../components/common/loading/LoadingSpinner";

interface LoadingContextType {
  isLoading: boolean;
  loadingText?: string;
  showLoading: (text?: string) => void;
  hideLoading: () => void;
}

const LoadingContext = createContext<LoadingContextType | undefined>(undefined);

export const LoadingProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [loadingText, setLoadingText] = useState<string | undefined>();

  const showLoading = useCallback((text?: string) => {
    setLoadingText(text);
    setIsLoading(true);
  }, []);

  const hideLoading = useCallback(() => {
    setIsLoading(false);
    setLoadingText(undefined);
  }, []);

  return (
    <LoadingContext.Provider
      value={{ isLoading, loadingText, showLoading, hideLoading }}
    >
      {children}
      {isLoading && (
        <View style={styles.loadingOverlay}>
          <LoadingSpinner text={loadingText} overlay />
        </View>
      )}
    </LoadingContext.Provider>
  );
};

export const useLoading = () => {
  const context = useContext(LoadingContext);
  if (context === undefined) {
    throw new Error("useLoading must be used within a LoadingProvider");
  }
  return context;
};

const styles = StyleSheet.create({
  loadingOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 9999,
  },
});
```

#### API ìš”ì²­ê³¼ ì—°ë™ëœ ë¡œë”© ê´€ë¦¬

```typescript
// hooks/useApiWithLoading.ts - API ìš”ì²­ê³¼ ë¡œë”© ìƒíƒœ ì—°ë™
import { useState, useCallback } from "react";
import { useLoading } from "../context/LoadingContext";

export const useApiWithLoading = () => {
  const { showLoading, hideLoading } = useLoading();
  const [isApiLoading, setIsApiLoading] = useState(false);

  const executeWithLoading = useCallback(async <T>(
    apiCall: () => Promise<T>,
    loadingText?: string
  ): Promise<T | null> => {
    try {
      setIsApiLoading(true);
      showLoading(loadingText);

      const result = await apiCall();
      return result;
    } catch (error) {
      console.error("API ìš”ì²­ ì‹¤íŒ¨:", error);
      return null;
    } finally {
      setIsApiLoading(false);
      hideLoading();
    }
  }, [showLoading, hideLoading]);

  return { executeWithLoading, isApiLoading };
};

// ì‚¬ìš© ì˜ˆì‹œ
const DiaryScreen = () => {
  const { executeWithLoading } = useApiWithLoading();

  const handleCreateDiary = async (diaryData: any) => {
    const result = await executeWithLoading(
      () => createDiaryEntry(diaryData),
      "ì¼ê¸°ë¥¼ ì €ì¥í•˜ëŠ” ì¤‘..."
    );

    if (result) {
      // ì„±ê³µ ì²˜ë¦¬
      console.log("ì¼ê¸° ì €ì¥ ì™„ë£Œ");
    }
  };

  return (
    // JSX
  );
};
```

### 2. React Queryì™€ ë¡œë”© ìƒíƒœ í†µí•©

```typescript
// hooks/useQueryWithLoading.ts - React Queryì™€ ë¡œë”© ìƒíƒœ í†µí•©
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useLoading } from "../context/LoadingContext";
import { useCallback } from "react";

export const useQueryWithLoading = <T>(
  queryKey: string[],
  queryFn: () => Promise<T>,
  options?: {
    loadingText?: string;
    enabled?: boolean;
    staleTime?: number;
  }
) => {
  const { showLoading, hideLoading } = useLoading();
  const [isLocalLoading, setIsLocalLoading] = useState(false);

  const query = useQuery({
    queryKey,
    queryFn: async () => {
      if (options?.loadingText) {
        setIsLocalLoading(true);
        showLoading(options.loadingText);
      }

      try {
        const result = await queryFn();
        return result;
      } finally {
        if (options?.loadingText) {
          setIsLocalLoading(false);
          hideLoading();
        }
      }
    },
    enabled: options?.enabled,
    staleTime: options?.staleTime,
  });

  return {
    ...query,
    isLoading: query.isLoading || isLocalLoading,
  };
};

export const useMutationWithLoading = <TData, TVariables>(
  mutationFn: (variables: TVariables) => Promise<TData>,
  options?: {
    loadingText?: string;
    onSuccess?: (data: TData) => void;
    onError?: (error: any) => void;
  }
) => {
  const { showLoading, hideLoading } = useLoading();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (variables: TVariables) => {
      if (options?.loadingText) {
        showLoading(options.loadingText);
      }

      try {
        const result = await mutationFn(variables);
        return result;
      } finally {
        if (options?.loadingText) {
          hideLoading();
        }
      }
    },
    onSuccess: (data) => {
      options?.onSuccess?.(data);
    },
    onError: (error) => {
      options?.onError?.(error);
    },
  });
};
```

### 3. ì•± ì´ˆê¸° ë¡œë”© ê´€ë¦¬

```typescript
// AppContent.tsx - ì•± ì´ˆê¸° ë¡œë”©ê³¼ ë°ì´í„° í”„ë¦¬ë¡œë”©
import React, { useEffect, useRef, useState } from "react";
import { useAuth } from "./context/AuthContext";
import { useQueryClient } from "@tanstack/react-query";
import {
  getDiaryCalendar,
  getAllChallenges,
  getMyChallenges,
  getUserInfo,
  getDiaryYear,
} from "@mooddisk/api";
import { queryKeys } from "./hooks/useQueries";
import LoadingSpinner from "./components/common/loading/LoadingSpinner";

const AppContent: React.FC = () => {
  const { user, isAuthenticated, token, login, updateToken, logout } =
    useAuth();
  const queryClient = useQueryClient();
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const hasPreloadedRef = useRef(false);

  // ì•± ì´ˆê¸° ë¡œë”© ì™„ë£Œ
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsInitialLoading(false);
    }, 2000); // ìµœì†Œ 2ì´ˆ ë¡œë”© í™”ë©´ í‘œì‹œ

    return () => clearTimeout(timer);
  }, []);

  // ë¡œê·¸ì¸ í›„ ë°±ê·¸ë¼ìš´ë“œ ë°ì´í„° í”„ë¦¬ë¡œë”©
  useEffect(() => {
    const preloadData = async () => {
      if (!isAuthenticated || !user || hasPreloadedRef.current) return;
      hasPreloadedRef.current = true;

      try {
        const now = new Date();
        const year = now.getFullYear();
        const month = now.getMonth() + 1;

        console.log("ğŸ”¥ ë°ì´í„° í”„ë¦¬ë¡œë”© ì‹œì‘");

        // ë³‘ë ¬ë¡œ ë°ì´í„° í”„ë¦¬ë¡œë”©
        await Promise.allSettled([
          queryClient.prefetchQuery({
            queryKey: queryKeys.diaryCalendar(year, month),
            queryFn: () => getDiaryCalendar(year, month),
            staleTime: 1000 * 60 * 5,
          }),
          queryClient.prefetchQuery({
            queryKey: queryKeys.allChallenges(),
            queryFn: getAllChallenges,
            staleTime: 1000 * 60 * 15,
          }),
          queryClient.prefetchQuery({
            queryKey: queryKeys.myChallenges(),
            queryFn: getMyChallenges,
            staleTime: 1000 * 60 * 5,
          }),
          queryClient.prefetchQuery({
            queryKey: queryKeys.diaryYear(year),
            queryFn: () => getDiaryYear(year),
            staleTime: 1000 * 60 * 10,
          }),
          user?.id
            ? queryClient.prefetchQuery({
                queryKey: queryKeys.userInfo(parseInt(user.id)),
                queryFn: () => getUserInfo(parseInt(user.id)),
                staleTime: 1000 * 60 * 30,
              })
            : Promise.resolve(),
        ]);

        console.log("ğŸ”¥ ë°ì´í„° í”„ë¦¬ë¡œë”© ì™„ë£Œ");
      } catch (error) {
        console.warn("ë°ì´í„° í”„ë¦¬ë¡œë”© ì‹¤íŒ¨:", error);
      }
    };

    preloadData();
  }, [isAuthenticated, user, queryClient]);

  // ì´ˆê¸° ë¡œë”© ì¤‘
  if (isInitialLoading) {
    return <LoadingSpinner text="ì•±ì„ ì‹œì‘í•˜ëŠ” ì¤‘..." />;
  }

  // ë¡œê·¸ì¸ ìƒíƒœì— ë”°ë¼ í™”ë©´ ë Œë”ë§
  if (isAuthenticated && user) {
    return <MainScreen />;
  }

  return <LoginScreen />;
};

export default AppContent;
```

## Performance Patterns

### 1. ë©”ëª¨ì´ì œì´ì…˜ íŒ¨í„´

```typescript
import React, { useCallback, useMemo } from "react";

const DiaryList = ({ diaries, onDiaryPress }) => {
  // í•¨ìˆ˜ ë©”ëª¨ì´ì œì´ì…˜
  const handleDiaryPress = useCallback(
    (diaryId: string) => {
      onDiaryPress(diaryId);
    },
    [onDiaryPress]
  );

  // ê°’ ë©”ëª¨ì´ì œì´ì…˜
  const sortedDiaries = useMemo(() => {
    return diaries.sort(
      (a, b) =>
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }, [diaries]);

  return (
    <FlatList
      data={sortedDiaries}
      renderItem={({ item }) => (
        <DiaryItem diary={item} onPress={() => handleDiaryPress(item.id)} />
      )}
      keyExtractor={(item) => item.id}
    />
  );
};
```

### 2. ì´ë¯¸ì§€ ìµœì í™”

```typescript
import FastImage from "react-native-fast-image";

const OptimizedImage = ({ source, style }) => {
  return (
    <FastImage
      source={source}
      style={style}
      resizeMode={FastImage.resizeMode.cover}
      // ìºì‹œ ì„¤ì •
      cache={FastImage.cacheControl.immutable}
    />
  );
};
```

## Error Handling

### 1. ì—ëŸ¬ ë°”ìš´ë”ë¦¬

```typescript
// components/common/ErrorBoundary.tsx
import React, { Component, ReactNode } from "react";
import { View, Text, StyleSheet } from "react-native";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.container}>
          <Text style={styles.title}>ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</Text>
          <Text style={styles.message}>
            {this.state.error?.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."}
          </Text>
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 8,
  },
  message: {
    fontSize: 14,
    color: "#666",
    textAlign: "center",
  },
});

export default ErrorBoundary;
```

## Best Practices

### 1. ì»´í¬ë„ŒíŠ¸ ì„¤ê³„ ì›ì¹™

- **ë‹¨ì¼ ì±…ì„ ì›ì¹™**: ê° ì»´í¬ë„ŒíŠ¸ëŠ” í•˜ë‚˜ì˜ ëª…í™•í•œ ì—­í• ì„ ê°€ì ¸ì•¼ í•¨
- **ì¬ì‚¬ìš©ì„±**: ê³µí†µ ì»´í¬ë„ŒíŠ¸ëŠ” ë‹¤ì–‘í•œ ìƒí™©ì—ì„œ ì¬ì‚¬ìš© ê°€ëŠ¥í•´ì•¼ í•¨
- **Props ì¸í„°í˜ì´ìŠ¤**: ëª…í™•í•œ TypeScript ì¸í„°í˜ì´ìŠ¤ ì •ì˜
- **ê¸°ë³¸ê°’ ì„¤ì •**: Propsì— ì ì ˆí•œ ê¸°ë³¸ê°’ ì œê³µ

### 2. ì„±ëŠ¥ ìµœì í™”

- **ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€**: useCallback, useMemo í™œìš©
- **ì´ë¯¸ì§€ ìµœì í™”**: FastImage ì‚¬ìš©
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬ ì‘ì—…
- **ë²ˆë“¤ í¬ê¸° ìµœì í™”**: í•„ìš”í•œ ëª¨ë“ˆë§Œ import

### 3. ì½”ë“œ í’ˆì§ˆ

- **TypeScript í™œìš©**: íƒ€ì… ì•ˆì „ì„± ë³´ì¥
- **ì—ëŸ¬ ì²˜ë¦¬**: ì ì ˆí•œ ì—ëŸ¬ ë°”ìš´ë”ë¦¬ì™€ try-catch ì‚¬ìš©
- **í…ŒìŠ¤íŠ¸**: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì™€ í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±
- **ë¬¸ì„œí™”**: ë³µì¡í•œ ë¡œì§ì— ëŒ€í•œ ì£¼ì„ ì‘ì„±

description: í˜„ì¬ ëª¨ë°”ì¼ ì•±ì˜ ì•„í‚¤í…ì²˜ íŒ¨í„´ê³¼ êµ¬ì¡° ê°€ì´ë“œë¼ì¸
globs:
alwaysApply: false

---

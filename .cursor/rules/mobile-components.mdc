# Mobile Components Guidelines

## Component Development Patterns

현재 모바일 앱의 컴포넌트 구조에 맞는 개발 가이드라인입니다.

## Component Categories

### 1. Common Components (`components/common/`)

재사용 가능한 공통 컴포넌트들로, 앱 전체에서 사용됩니다.

#### Button Components

```typescript
// components/common/buttons/ActionButton.tsx
import React, { useCallback } from "react";
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  ActivityIndicator,
} from "react-native";

interface ActionButtonProps {
  title: string;
  onPress?: () => void;
  variant?: "primary" | "secondary" | "danger";
  size?: "small" | "medium" | "large";
  disabled?: boolean;
  loading?: boolean;
  icon?: React.ReactNode;
}

const ActionButton: React.FC<ActionButtonProps> = ({
  title,
  onPress,
  variant = "primary",
  size = "medium",
  disabled = false,
  loading = false,
  icon,
}) => {
  const handlePress = useCallback(() => {
    if (!disabled && !loading && onPress) {
      onPress();
    }
  }, [onPress, disabled, loading]);

  return (
    <TouchableOpacity
      style={[
        styles.button,
        styles[variant],
        styles[size],
        (disabled || loading) && styles.disabled,
      ]}
      onPress={handlePress}
      disabled={disabled || loading}
      activeOpacity={0.7}
    >
      {loading ? (
        <ActivityIndicator
          color={variant === "primary" ? "#FFFFFF" : "#007AFF"}
        />
      ) : (
        <>
          {icon && <View style={styles.iconContainer}>{icon}</View>}
          <Text
            style={[
              styles.text,
              styles[`${variant}Text`],
              styles[`${size}Text`],
            ]}
          >
            {title}
          </Text>
        </>
      )}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: 8,
    minHeight: 44, // 터치 친화적 최소 높이
  },
  primary: {
    backgroundColor: "#007AFF",
  },
  secondary: {
    backgroundColor: "#F2F2F7",
    borderWidth: 1,
    borderColor: "#E5E5EA",
  },
  danger: {
    backgroundColor: "#FF3B30",
  },
  small: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    minHeight: 36,
  },
  medium: {
    paddingHorizontal: 24,
    paddingVertical: 12,
  },
  large: {
    paddingHorizontal: 32,
    paddingVertical: 16,
    minHeight: 52,
  },
  disabled: {
    opacity: 0.5,
  },
  text: {
    fontWeight: "600",
    textAlign: "center",
  },
  primaryText: {
    color: "#FFFFFF",
  },
  secondaryText: {
    color: "#000000",
  },
  dangerText: {
    color: "#FFFFFF",
  },
  smallText: {
    fontSize: 14,
  },
  mediumText: {
    fontSize: 16,
  },
  largeText: {
    fontSize: 18,
  },
  iconContainer: {
    marginRight: 8,
  },
});

export default ActionButton;
```

#### Form Components

```typescript
// components/common/forms/Input.tsx
import React, { useState, useCallback } from "react";
import {
  View,
  TextInput,
  Text,
  StyleSheet,
  TouchableOpacity,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";

interface InputProps {
  label?: string;
  placeholder?: string;
  value: string;
  onChangeText: (text: string) => void;
  secureTextEntry?: boolean;
  error?: string;
  disabled?: boolean;
  multiline?: boolean;
  numberOfLines?: number;
  keyboardType?: "default" | "email-address" | "numeric" | "phone-pad";
  autoCapitalize?: "none" | "sentences" | "words" | "characters";
  maxLength?: number;
  leftIcon?: keyof typeof Ionicons.glyphMap;
  rightIcon?: keyof typeof Ionicons.glyphMap;
  onRightIconPress?: () => void;
}

const Input: React.FC<InputProps> = ({
  label,
  placeholder,
  value,
  onChangeText,
  secureTextEntry = false,
  error,
  disabled = false,
  multiline = false,
  numberOfLines = 1,
  keyboardType = "default",
  autoCapitalize = "sentences",
  maxLength,
  leftIcon,
  rightIcon,
  onRightIconPress,
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const [isSecure, setIsSecure] = useState(secureTextEntry);

  const handleFocus = useCallback(() => {
    setIsFocused(true);
  }, []);

  const handleBlur = useCallback(() => {
    setIsFocused(false);
  }, []);

  const toggleSecure = useCallback(() => {
    setIsSecure(!isSecure);
  }, [isSecure]);

  return (
    <View style={styles.container}>
      {label && <Text style={styles.label}>{label}</Text>}
      <View
        style={[
          styles.inputContainer,
          isFocused && styles.focused,
          error && styles.error,
          disabled && styles.disabled,
        ]}
      >
        {leftIcon && (
          <Ionicons
            name={leftIcon}
            size={20}
            color={isFocused ? "#007AFF" : "#8E8E93"}
            style={styles.leftIcon}
          />
        )}
        <TextInput
          style={[styles.input, multiline && styles.multilineInput]}
          placeholder={placeholder}
          placeholderTextColor="#8E8E93"
          value={value}
          onChangeText={onChangeText}
          secureTextEntry={isSecure}
          editable={!disabled}
          multiline={multiline}
          numberOfLines={numberOfLines}
          keyboardType={keyboardType}
          autoCapitalize={autoCapitalize}
          maxLength={maxLength}
          onFocus={handleFocus}
          onBlur={handleBlur}
        />
        {secureTextEntry && (
          <TouchableOpacity onPress={toggleSecure} style={styles.rightIcon}>
            <Ionicons
              name={isSecure ? "eye-off" : "eye"}
              size={20}
              color="#8E8E93"
            />
          </TouchableOpacity>
        )}
        {rightIcon && !secureTextEntry && (
          <TouchableOpacity onPress={onRightIconPress} style={styles.rightIcon}>
            <Ionicons name={rightIcon} size={20} color="#8E8E93" />
          </TouchableOpacity>
        )}
      </View>
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: "600",
    color: "#000000",
    marginBottom: 8,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#E5E5EA",
    borderRadius: 8,
    backgroundColor: "#FFFFFF",
    paddingHorizontal: 12,
    minHeight: 44,
  },
  focused: {
    borderColor: "#007AFF",
  },
  error: {
    borderColor: "#FF3B30",
  },
  disabled: {
    backgroundColor: "#F2F2F7",
    opacity: 0.6,
  },
  input: {
    flex: 1,
    fontSize: 16,
    color: "#000000",
    paddingVertical: 12,
  },
  multilineInput: {
    minHeight: 80,
    textAlignVertical: "top",
  },
  leftIcon: {
    marginRight: 8,
  },
  rightIcon: {
    marginLeft: 8,
    padding: 4,
  },
  errorText: {
    fontSize: 14,
    color: "#FF3B30",
    marginTop: 4,
  },
});

export default Input;
```

#### Loading Components

```typescript
// components/common/loading/LoadingSpinner.tsx
import React from "react";
import { View, ActivityIndicator, Text, StyleSheet } from "react-native";

interface LoadingSpinnerProps {
  size?: "small" | "large";
  color?: string;
  text?: string;
  overlay?: boolean;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = "large",
  color = "#007AFF",
  text,
  overlay = false,
}) => {
  const containerStyle = overlay ? styles.overlay : styles.container;

  return (
    <View style={containerStyle}>
      <ActivityIndicator size={size} color={color} />
      {text && <Text style={styles.text}>{text}</Text>}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  overlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(255, 255, 255, 0.8)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 1000,
  },
  text: {
    marginTop: 12,
    fontSize: 16,
    color: "#666666",
    textAlign: "center",
  },
});

export default LoadingSpinner;
```

#### 로딩 오버레이 컴포넌트

```typescript
// components/common/loading/LoadingOverlay.tsx
import React from "react";
import { View, StyleSheet, Modal } from "react-native";
import LoadingSpinner from "./LoadingSpinner";

interface LoadingOverlayProps {
  visible: boolean;
  text?: string;
  transparent?: boolean;
}

const LoadingOverlay: React.FC<LoadingOverlayProps> = ({
  visible,
  text,
  transparent = false,
}) => {
  return (
    <Modal
      transparent={transparent}
      visible={visible}
      animationType="fade"
      statusBarTranslucent
    >
      <View style={styles.overlay}>
        <View style={styles.container}>
          <LoadingSpinner text={text} />
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "center",
    alignItems: "center",
  },
  container: {
    backgroundColor: "#FFFFFF",
    borderRadius: 12,
    padding: 24,
    minWidth: 120,
    alignItems: "center",
  },
});

export default LoadingOverlay;
```

#### 스켈레톤 로딩 컴포넌트

```typescript
// components/common/loading/SkeletonLoader.tsx
import React, { useEffect, useRef } from "react";
import { View, StyleSheet, Animated } from "react-native";

interface SkeletonLoaderProps {
  width?: number | string;
  height?: number;
  borderRadius?: number;
  style?: any;
}

const SkeletonLoader: React.FC<SkeletonLoaderProps> = ({
  width = "100%",
  height = 20,
  borderRadius = 4,
  style,
}) => {
  const animatedValue = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    const animation = Animated.loop(
      Animated.sequence([
        Animated.timing(animatedValue, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: false,
        }),
        Animated.timing(animatedValue, {
          toValue: 0,
          duration: 1000,
          useNativeDriver: false,
        }),
      ])
    );
    animation.start();

    return () => animation.stop();
  }, [animatedValue]);

  const backgroundColor = animatedValue.interpolate({
    inputRange: [0, 1],
    outputRange: ["#F2F2F7", "#E5E5EA"],
  });

  return (
    <Animated.View
      style={[
        styles.skeleton,
        {
          width,
          height,
          borderRadius,
          backgroundColor,
        },
        style,
      ]}
    />
  );
};

const styles = StyleSheet.create({
  skeleton: {
    backgroundColor: "#F2F2F7",
  },
});

// 스켈레톤 리스트 컴포넌트
export const SkeletonList: React.FC<{ count?: number }> = ({ count = 5 }) => {
  return (
    <View style={styles.list}>
      {Array.from({ length: count }).map((_, index) => (
        <View key={index} style={styles.listItem}>
          <SkeletonLoader width={40} height={40} borderRadius={20} />
          <View style={styles.listContent}>
            <SkeletonLoader width="70%" height={16} style={styles.title} />
            <SkeletonLoader width="50%" height={14} />
          </View>
        </View>
      ))}
    </View>
  );
};

const listStyles = StyleSheet.create({
  list: {
    padding: 16,
  },
  listItem: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 16,
  },
  listContent: {
    flex: 1,
    marginLeft: 12,
  },
  title: {
    marginBottom: 8,
  },
});

export default SkeletonLoader;
```

### 2. Feature Components (`components/features/`)

특정 기능에 특화된 컴포넌트들입니다.

#### Diary Components

```typescript
// components/features/diary/calendar/DiaryCalendar.tsx
import React, { useState, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
} from "react-native";
import { useDiaryCalendar } from "@mooddisk/hooks";
import LoadingSpinner from "../../common/loading/LoadingSpinner";

interface DiaryCalendarProps {
  onDateSelect: (date: Date) => void;
  selectedDate?: Date;
}

const DiaryCalendar: React.FC<DiaryCalendarProps> = ({
  onDateSelect,
  selectedDate,
}) => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const {
    data: diaryData,
    isLoading,
    error,
  } = useDiaryCalendar(currentDate.getFullYear(), currentDate.getMonth() + 1);

  const handleDatePress = useCallback(
    (date: Date) => {
      onDateSelect(date);
    },
    [onDateSelect]
  );

  const renderCalendarDay = useCallback(
    ({ item: date }: { item: Date }) => {
      const isSelected = selectedDate?.toDateString() === date.toDateString();
      const hasDiary = diaryData?.some(
        (diary) => new Date(diary.date).toDateString() === date.toDateString()
      );

      return (
        <TouchableOpacity
          style={[
            styles.dayContainer,
            isSelected && styles.selectedDay,
            hasDiary && styles.dayWithDiary,
          ]}
          onPress={() => handleDatePress(date)}
        >
          <Text style={[styles.dayText, isSelected && styles.selectedDayText]}>
            {date.getDate()}
          </Text>
          {hasDiary && <View style={styles.diaryIndicator} />}
        </TouchableOpacity>
      );
    },
    [selectedDate, diaryData, handleDatePress]
  );

  if (isLoading) {
    return <SkeletonList count={7} />; // 스켈레톤 로딩 사용
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>일기 데이터를 불러올 수 없습니다.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>일기 달력</Text>
      <FlatList
        data={generateCalendarDays(currentDate)}
        renderItem={renderCalendarDay}
        keyExtractor={(item) => item.toISOString()}
        numColumns={7}
        contentContainerStyle={styles.calendarGrid}
      />
    </View>
  );
};

const generateCalendarDays = (date: Date): Date[] => {
  // 달력 날짜 생성 로직
  const year = date.getFullYear();
  const month = date.getMonth();
  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  const days: Date[] = [];

  for (let i = 1; i <= lastDay.getDate(); i++) {
    days.push(new Date(year, month, i));
  }

  return days;
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 16,
    textAlign: "center",
  },
  calendarGrid: {
    paddingBottom: 20,
  },
  dayContainer: {
    flex: 1,
    aspectRatio: 1,
    justifyContent: "center",
    alignItems: "center",
    margin: 2,
    borderRadius: 8,
    backgroundColor: "#F2F2F7",
  },
  selectedDay: {
    backgroundColor: "#007AFF",
  },
  dayWithDiary: {
    borderWidth: 2,
    borderColor: "#34C759",
  },
  dayText: {
    fontSize: 16,
    color: "#000000",
  },
  selectedDayText: {
    color: "#FFFFFF",
    fontWeight: "bold",
  },
  diaryIndicator: {
    position: "absolute",
    bottom: 4,
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: "#34C759",
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: "#FF3B30",
    textAlign: "center",
  },
});

export default DiaryCalendar;
```

### 3. Screen Components (`screens/`)

전체 화면을 담당하는 컴포넌트들입니다.

```typescript
// screens/DiaryScreen.tsx - 중앙관리 패턴 적용
import React, { useState, useCallback } from "react";
import { View, StyleSheet, SafeAreaView } from "react-native";
import MainLayout from "../layouts/MainLayout";
import DiaryCalendar from "../components/features/diary/calendar/DiaryCalendar";
import DiaryList from "../components/features/diary/list/DiaryList";
import FAB from "../components/common/buttons/FAB";
import {
  useQueryWithLoading,
  useMutationWithLoading,
} from "../hooks/useQueryWithLoading";
import { queryKeys } from "../hooks/useQueries";
import { createDiaryEntry } from "@mooddisk/api";
import { useLoading } from "../context/LoadingContext";

const DiaryScreen: React.FC = () => {
  const [selectedDate, setSelectedDate] = useState<Date | undefined>();
  const [showCalendar, setShowCalendar] = useState(true);
  const { showLoading, hideLoading } = useLoading();

  const handleDateSelect = useCallback((date: Date) => {
    setSelectedDate(date);
    setShowCalendar(false);
  }, []);

  // 일기 생성 뮤테이션 (중앙관리 로딩과 연동)
  const createDiaryMutation = useMutationWithLoading(createDiaryEntry, {
    loadingText: "일기를 저장하는 중...",
    onSuccess: (data) => {
      console.log("일기 저장 완료:", data);
      // 성공 후 처리
    },
    onError: (error) => {
      console.error("일기 저장 실패:", error);
      // 에러 처리
    },
  });

  const handleWriteDiary = useCallback(() => {
    // 일기 작성 화면으로 이동
    console.log("일기 작성");
  }, []);

  // 테스트용 일기 생성 함수
  const handleTestCreateDiary = useCallback(() => {
    const testDiaryData = {
      title: "테스트 일기",
      content: "테스트 내용",
      date: new Date().toISOString(),
    };

    createDiaryMutation.mutate(testDiaryData);
  }, [createDiaryMutation]);

  return (
    <SafeAreaView style={styles.container}>
      <MainLayout>
        {showCalendar ? (
          <DiaryCalendar
            onDateSelect={handleDateSelect}
            selectedDate={selectedDate}
          />
        ) : (
          <DiaryList selectedDate={selectedDate} />
        )}
        <FAB onPress={handleWriteDiary} />

        {/* 테스트용 버튼 */}
        <View style={styles.testButton}>
          <FAB onPress={handleTestCreateDiary} />
        </View>
      </MainLayout>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#FFFFFF",
  },
  testButton: {
    position: "absolute",
    bottom: 100,
    right: 20,
  },
});

export default DiaryScreen;
```

#### 중앙관리 로딩을 사용하는 리스트 컴포넌트

```typescript
// components/features/diary/list/DiaryList.tsx
import React, { useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
} from "react-native";
import { useQueryWithLoading } from "../../../hooks/useQueryWithLoading";
import { queryKeys } from "../../../hooks/useQueries";
import { getDiaryList } from "@mooddisk/api";
import SkeletonList from "../../common/loading/SkeletonList";
import { DiaryEntry } from "@mooddisk/types";

interface DiaryListProps {
  selectedDate?: Date;
}

const DiaryList: React.FC<DiaryListProps> = ({ selectedDate }) => {
  // 중앙관리 로딩과 연동된 쿼리
  const {
    data: diaryList,
    isLoading,
    error,
  } = useQueryWithLoading(
    queryKeys.diaryList(selectedDate),
    () => getDiaryList(selectedDate),
    {
      loadingText: "일기 목록을 불러오는 중...",
      enabled: !!selectedDate,
      staleTime: 1000 * 60 * 5, // 5분
    }
  );

  const renderDiaryItem = useCallback(({ item }: { item: DiaryEntry }) => {
    return (
      <TouchableOpacity style={styles.diaryItem}>
        <Text style={styles.diaryTitle}>{item.title}</Text>
        <Text style={styles.diaryContent} numberOfLines={2}>
          {item.content}
        </Text>
        <Text style={styles.diaryDate}>
          {new Date(item.createdAt).toLocaleDateString()}
        </Text>
      </TouchableOpacity>
    );
  }, []);

  if (isLoading) {
    return <SkeletonList count={5} />;
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>일기 목록을 불러올 수 없습니다.</Text>
      </View>
    );
  }

  if (!diaryList || diaryList.length === 0) {
    return (
      <View style={styles.emptyContainer}>
        <Text style={styles.emptyText}>작성된 일기가 없습니다.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={diaryList}
        renderItem={renderDiaryItem}
        keyExtractor={(item) => item.id.toString()}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  listContainer: {
    paddingBottom: 20,
  },
  diaryItem: {
    backgroundColor: "#FFFFFF",
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  diaryTitle: {
    fontSize: 16,
    fontWeight: "bold",
    color: "#000000",
    marginBottom: 8,
  },
  diaryContent: {
    fontSize: 14,
    color: "#666666",
    lineHeight: 20,
    marginBottom: 8,
  },
  diaryDate: {
    fontSize: 12,
    color: "#999999",
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: "#FF3B30",
    textAlign: "center",
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  emptyText: {
    fontSize: 16,
    color: "#999999",
    textAlign: "center",
  },
});

export default DiaryList;
```

## Component Development Rules

### 1. Props Interface 정의

```typescript
// 모든 컴포넌트는 명확한 Props 인터페이스를 가져야 함
interface ComponentProps {
  // 필수 props
  title: string;
  onPress: () => void;

  // 선택적 props
  variant?: "primary" | "secondary";
  disabled?: boolean;
  loading?: boolean;

  // 이벤트 핸들러
  onPress?: () => void;
  onChange?: (value: string) => void;

  // 스타일 관련
  style?: ViewStyle;
  textStyle?: TextStyle;
}
```

### 2. 기본값 설정

```typescript
// Props에 적절한 기본값 제공
const Component: React.FC<ComponentProps> = ({
  variant = "primary",
  disabled = false,
  loading = false,
  ...props
}) => {
  // 컴포넌트 로직
};
```

### 3. 메모이제이션 활용

```typescript
// 함수와 값의 메모이제이션
const Component: React.FC<Props> = ({ data, onItemPress }) => {
  const handleItemPress = useCallback((item: Item) => {
    onItemPress(item);
  }, [onItemPress]);

  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: true,
    }));
  }, [data]);

  return (
    // JSX
  );
};
```

### 4. 에러 처리

```typescript
// 컴포넌트 레벨 에러 처리
const Component: React.FC<Props> = ({ data }) => {
  if (!data) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>데이터를 불러올 수 없습니다.</Text>
      </View>
    );
  }

  return (
    // 정상 렌더링
  );
};
```

## Styling Guidelines

### 1. StyleSheet 사용

```typescript
// 모든 스타일은 StyleSheet.create() 사용
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#FFFFFF",
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    color: "#000000",
  },
});
```

### 2. 터치 친화적 디자인

```typescript
// 최소 터치 영역 44px 보장
const styles = StyleSheet.create({
  button: {
    minHeight: 44,
    minWidth: 44,
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
});
```

### 3. 반응형 디자인

```typescript
import { Dimensions } from "react-native";

const { width, height } = Dimensions.get("window");

const styles = StyleSheet.create({
  container: {
    width: width * 0.9, // 화면 너비의 90%
    maxWidth: 400, // 최대 너비 제한
  },
});
```

## Testing Guidelines

### 1. 컴포넌트 테스트

```typescript
// components/__tests__/ActionButton.test.tsx
import React from "react";
import { render, fireEvent } from "@testing-library/react-native";
import ActionButton from "../ActionButton";

describe("ActionButton", () => {
  it("renders correctly with title", () => {
    const { getByText } = render(
      <ActionButton title="Test Button" onPress={() => {}} />
    );

    expect(getByText("Test Button")).toBeTruthy();
  });

  it("calls onPress when pressed", () => {
    const mockOnPress = jest.fn();
    const { getByText } = render(
      <ActionButton title="Test Button" onPress={mockOnPress} />
    );

    fireEvent.press(getByText("Test Button"));
    expect(mockOnPress).toHaveBeenCalledTimes(1);
  });

  it("does not call onPress when disabled", () => {
    const mockOnPress = jest.fn();
    const { getByText } = render(
      <ActionButton title="Test Button" onPress={mockOnPress} disabled />
    );

    fireEvent.press(getByText("Test Button"));
    expect(mockOnPress).not.toHaveBeenCalled();
  });
});
```

description: 모바일 컴포넌트 개발 가이드라인 및 패턴
globs:
alwaysApply: false

---
